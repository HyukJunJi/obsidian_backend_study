---
tags: http, Internet
---
[[HTTP]]는 클라이언트와 서버가 서로 통신하는 방식을 표준화하는 TCP/IP 기반 애플리케이션 계층 통신 프로토콜입니다. 인터넷을 통해 콘텐츠가 요청되고 전송되는 방식을 정의합니다. 애플리케이션 계층 프로토콜이란 단순히 호스트(클라이언트 및 서버)가 통신하는 방식을 표준화하는 추상화 계층임을 의미합니다. HTTP 자체는 클라이언트와 서버 간의 요청과 응답을 얻기 위해 TCP/IP에 의존합니다. 기본적으로 TCP 포트 80이 사용되지만 다른 포트도 사용할 수 있습니다. 그러나 <U>HTTPS는 포트 443</U>을 사용합니다.

## HTTP/0.9 - 원 라이너(1991)
HTTP의 첫 번째 문서화된 버전은 1991년에 발표된 [HTTP/0.9 였습니다. 이는 지금까지 가장 간단한 프로토콜이었습니다.](https://www.w3.org/Protocols/HTTP/AsImplemented.html) GET이라는 단일 메서드가 있습니다. 클라이언트가 서버의 일부 웹페이지에 액세스해야 한다면 아래와 같은 간단한 요청을 수행했을 것입니다.
```http
GET /index.html
```
그리고 서버의 응답은 다음과 같습니다.

```http
(response body)
(connection closed)
```
즉, 서버는 요청을 받고 응답으로 HTML로 응답하며 콘텐츠가 전송되자마자 연결이 닫힙니다. 있었다

- ==헤더 없음==
- `GET`유일하게 허용된 방법이었습니다
- ==응답은 HTML==이어야 했습니다.

보시다시피, 프로토콜은 실제로 앞으로 다가올 일을 위한 디딤돌 역할을 하는 것 이상이었습니다.

## HTTP/1.0 - 1996
1996년에 HTTP의 다음 버전, 즉 HTTP/1.0이 발전하여 원래 버전보다 크게 향상되었습니다.

HTML 응답용으로만 설계된 HTTP/0.9와 달리 HTTP/1.0은 이제 다른 응답 형식(예: 이미지, 비디오 파일, 일반 텍스트 또는 기타 콘텐츠 유형)도 처리할 수 있습니다. 더 많은 메소드(예: POST 및 HEAD) 추가, 요청/응답 형식 변경, 요청과 응답 모두에 HTTP 헤더 추가, 응답 식별을 위한 상태 코드 추가, 문자 세트 지원 도입, 다중 부분 유형, 인증 , 캐싱, 콘텐츠 인코딩 등이 포함되었습니다.

샘플 HTTP/1.0 요청 및 응답은 다음과 같습니다.

```http
GET / HTTP/1.0
Host: cs.fyi
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```
보시다시피, 클라이언트는 요청과 함께 개인 정보, 필수 응답 유형 등도 보냈습니다. HTTP/0.9에서는 헤더가 없기 때문에 클라이언트가 그러한 정보를 보낼 수 없었습니다.

위 요청에 대한 응답 예시는 다음과 같을 수 있습니다.
```http
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)
```

응답의 맨 처음에는 HTTP/1.0(HTTP와 버전 번호)이 있고, 상태 코드 200과 이유 문구(또는 상태 코드에 대한 설명)가 있습니다.
이 최신 버전에서는 요청 및 응답 헤더가 여전히 ASCII 인코딩으로 유지되었지만 <U>응답 본문은 이미지, 비디오, HTML, 일반 텍스트 또는 기타 콘텐츠 유형 등 모든 유형</U>이 될 수 있습니다. 이제 해당 <U>서버는 모든 콘텐츠 유형</U>을 클라이언트에 보낼 수 있습니다.
##### 단점
HTTP/1.0의 주요 단점 중 하나는 연결당 여러 요청을 가질 수 없다는 것입니다.
즉, 클라이언트가 서버로부터 무언가를 필요로 할 때마다 새로운 TCP 연결을 열어야 하며 해당 단일 요청이 이행된 후에는 연결이 닫힙니다.
그리고 다음 요구 사항을 위해서는 새로운 연결이 필요합니다.

### Three-way Handshake

간단한 형태의 3방향 핸드셰이크는 모든 TCP 연결이 애플리케이션 데이터 공유를 시작하기 전에 클라이언트와 서버가 일련의 패킷을 공유하는 3방향 핸드셰이크로 시작한다는 것입니다.
- SYN - 클라이언트가 임의의 숫자(x라고 가정)를 선택하여 서버로 보냅니다.
- SYN ACK - 서버는 임의의 숫자로 구성된 ACK 패킷을 클라이언트에 다시 보냄으로써 요청을 승인합니다. 서버가 y를 선택하고 숫자 x+1을 가정해 보겠습니다. 여기서 x는 클라이언트가 보낸 숫자입니다.
- ACK - 클라이언트는 서버로부터 받은 숫자 y를 증가시키고 숫자 y+1이 포함된 ACK 패킷을 다시 보냅니다.
3방향 핸드셰이크가 완료되면 클라이언트와 서버 간의 데이터 공유가 시작될 수 있습니다. 클라이언트는 마지막 ACK 패킷을 발송하자마자 애플리케이션 데이터 전송을 시작할 수 있지만 서버는 요청을 이행하기 위해 ACK 패킷이 수신될 때까지 기다려야 합니다.
![사진](https://i.imgur.com/ohZthqB.png)
연결이 없는 것 외에도 HTTP는 상태 비저장 프로토콜입니다. 즉, 서버는 클라이언트에 대한 정보를 유지하지 않으므로 각 요청에는 서버가 이전과의 연결 없이 자체적으로 요청을 이행하는 데 필요한 정보가 있어야 합니다. 즉, 클라이언트가 열어야 하는 많은 수의 연결 외에도 유선으로 일부 중복 데이터를 보내 대역폭 사용량을 증가시켜야 합니다.

## HTTP/1.1 - 1997
HTTP/1.0이 출시된 지 불과 3년 만에 1999년에 다음 버전인 HTTP/1.1이 출시되었습니다.
- ==PUT, PATCH, OPTIONS, DELETE==를 도입한 새로운 HTTP 메소드가 추가되었습니다.
- HTTP/1.0의 호스트 이름 ==식별 호스트 헤더==는 필수가 아니었지만 HTTP/1.1에서는 ==필수==로 만들었습니다.
- HTTP/1.0에서는 연결당 요청이 하나만 있었고 요청이 충족되자마자 연결이 닫혀 심각한 성능 저하 및 대기 시간 문제가 발생했지만, HTTP/1.1은 지속적인 연결을 도입했습니다. 즉, 연결은 기본적으로 닫히지 않고 열린 상태로 유지되어 여러 순차적 요청을 허용했습니다. 연결을 닫으려면 요청에서 Connection: close 헤더를 사용할 수 있어야 했습니다. 클라이언트는 일반적으로 연결을 안전하게 종료하기 위해 마지막 요청에서 이 헤더를 보냅니다.
- 파이프라이닝 또한 클라이언트가 동일한 연결에서 서버의 응답을 기다리지 않고 ==서버에 여러 요청을 보낼 수 있고 서버는 요청이 수신된 것과 동일한 순서로 응답을 보내야 하는== 파이프 라이닝에 대한 지원을 도입했습니다. 그러나 <U>클라이언트는 이것이 첫 번째 응답 다운로드가 완료되고 다음 응답에 대한 콘텐츠가 시작되는 지점임을 어떻게 알 수 있습니까?</U> 이 문제를 해결하려면 ==클라이언트가 응답이 끝나는 위치를 식별하고 다음 응답을 기다리기 시작할 수 있는 Content-Length 헤더==가 있어야 합니다.
- ![사진](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F993666415BC2DD3231)
>[!notice]
><u>지속적인 연결</u>이나 <u>파이프라인의 이점을 얻으려면</u> <u>응답에서 Content-Length 헤더를 사용할 수</u> 있어야 합니다. 이는 <u>전송이 완료</u>되면 <u>클라이언트에게 알려주고</u> <u>다음 요청을 보내</u>거나(요청을 보내는 일반적인 순차적 방식으로) <u>다음 응답을 기다리기</u> 시작할 수 있기 때문입니다(파이프라인이 활성화된 경우).
>==하지만== 이 접근 방식에는 여전히 <u>문제가 있었</u>습니다. 즉, <u>데이터가 동적</u>이고 <u>서버가 콘텐츠 길이를 미리 찾을 수 없다</u>면 어떻게 될까요? 그렇다면 <u>지속적인 연결</u>의 <u>이점을 누릴 수는 없습</u>니다. 이 <u>문제를 해결</u>하기 위해 <u>HTTP/1.1에서는 청크 인코딩^[- 청크 전송 동적 콘텐츠의 경우 전송이 시작될 때 서버가 실제로 Content-Length를 찾을 수 없으면 콘텐츠를 조각으로(청크별로) 전송하기 시작하고 전송 시 각 청크에 대해 Content-Length를 추가할 수 있습니다. . 그리고 모든 청크가 전송되면, 즉 전체 전송이 완료되면 전송이 완료된 클라이언트를 식별하기 위해 빈 청크, 즉 Content-Length가 0으로 설정된 청크를 보냅니다. 청크 전송에 대해 클라이언트에 알리기 위해 서버는 Transfer-Encoding: Chunked 헤더를 포함합니다.]</u>을 도입했습니다. 이러한 경우 서버는 <u>청크 분할 인코딩을 위해 content-Length를 생략</u>할 수 있습니다. 그러나 그 중 어느 것도 사용 가능하지 않으면 요청이 끝날 때 연결을 닫아야 합니다.
- 기본 인증만 있었던 HTTP/1.0과 달리 HTTP/1.1에는 다이제스트 및 프록시 인증이 포함되었습니다.
    
- 캐싱
    
- 바이트 범위
    
- 문자 세트
    
- 언어 협상
    
- 클라이언트 쿠키
    
- 향상된 압축 지원
    
- 새로운 상태 코드
    
- ..그리고 더

[[HTTP의 구조]]
[[HTTPS]]
[출처](https://cs.fyi/guide/http-in-depth)

[심화자료](https://datatracker.ietf.org/doc/html/rfc2616)